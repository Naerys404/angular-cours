<div class="max-w-5xl mx-auto mt-10 space-y-8">
  <h1 class="text-4xl font-bold text-center text-primary">
    Introduction aux Observables
  </h1>

  <div class="alert alert-info shadow-lg">
    <div>
      <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <div>
        <h4 class="font-bold text-lg">Qu'est-ce qu'un Observable ?</h4>
        <p class="mt-2">
          Un <strong>Observable</strong> est une source de données asynchrones qui émet des valeurs au fil du temps.
          Contrairement aux promesses (<code>Promises</code>), qui ne renvoient qu'une seule valeur,
          un observable peut émettre plusieurs valeurs successivement.
        </p>
        <h5 class="font-semibold mt-4">Les Observables sont utiles pour :</h5>
        <ul class="list-disc list-inside mt-2 space-y-1">
          <li>Les opérations asynchrones comme les appels API (<code>HttpClient</code>).</li>
          <li>Gérer les événements utilisateurs (clics, frappes clavier, etc.).</li>
          <li>Traiter des flux de données comme les WebSockets ou les données temps réel.</li>
          <li>Coordonner plusieurs tâches complexes, enchaînées ou parallèles.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="alert alert-secondary shadow-lg">
    <div>
      <h4 class="font-bold text-lg">Qu'est-ce que RxJS ?</h4>
      <p class="mt-2">
        <strong>RxJS</strong> (Reactive Extensions for JavaScript) est une bibliothèque puissante utilisée pour
        créer et manipuler des observables. Elle propose un grand nombre d'<em>opérateurs</em> comme
        <code>map</code>, <code>filter</code>, <code>merge</code> ou <code>switchMap</code>.
      </p>
      <p class="mt-2">
        Angular utilise RxJS pour fournir des outils réactifs comme <code>HttpClient</code>, les <code>Forms</code>
        réactifs, et les événements de composants.
      </p>
    </div>
  </div>

  ---

  <div class="card bg-base-100 shadow-xl">
    <div class="card-body">
      <h3 class="card-title text-accent">Cycle de Vie : `subscribe()` et `unsubscribe()`</h3>
      <p>
        Un Observable est "froid" : il ne commence à émettre des valeurs qu'à partir du moment où quelqu'un s'y **abonne**.
      </p>

      <ul class="list-disc list-inside mt-4 space-y-2">
        <li>
          <h5 class="font-bold">`subscribe(observer)`</h5>
          <p class="ml-4">C'est la méthode qui **active** l'Observable et le lie à un **Observer**. L'Observer est l'objet qui contient les méthodes de gestion des valeurs (<code>next</code>, <code>error</code>, <code>complete</code>).</p>
        </li>
        <li>
          <h5 class="font-bold">`unsubscribe()`</h5>
          <p class="ml-4">Méthode essentielle appelée sur l'objet retourné par <code>subscribe()</code>. Elle **arrête** l'écoute des valeurs et libère les ressources.

[Image of Observable lifecycle]

          </p>
        </li>
      </ul>

      <div class="alert alert-warning mt-4">
        <div>
          <strong>Règle d'or :</strong> Pour les Observables qui n'achèvent pas leur cycle naturellement (comme <code>interval</code> ou les événements), vous devez toujours appeler <code>.unsubscribe()</code> dans le <code>ngOnDestroy()</code> du composant pour éviter les **fuites de mémoire**.
        </div>
      </div>
    </div>
  </div>

  ---

  <div class="card bg-base-100 shadow-xl">
    <div class="card-body">
      <h3 class="card-title text-success">Méthodes clés de l'Observer</h3>
      <p>
        L'objet passé à <code>subscribe()</code> (l'Observer) définit la façon dont le flux est géré :
      </p>
      <ul class="list-disc list-inside mt-4 space-y-2">
        <li>
          <h5 class="font-bold text-success">`.next(value)`</h5>
          <p class="ml-4">C'est la fonction la plus utilisée. Elle est appelée à chaque fois que la source **émet une nouvelle valeur** vers ses abonnés.</p>
        </li>
        <li>
          <h5 class="font-bold text-error">`.error(err)`</h5>
          <p class="ml-4">Appelée si une erreur survient dans le flux. Une fois l'erreur émise, l'Observable **s'arrête** et n'émettra plus de valeurs.</p>
        </li>
        <li>
          <h5 class="font-bold text-info">`.complete()`</h5>
          <p class="ml-4">Appelée lorsque l'Observable a terminé son travail et n'émettra plus de valeurs. Une fois `complete` appelé, l'Observable **s'arrête**.</p>
        </li>
      </ul>

      <h3 class="card-title text-primary mt-6">Opérateur de Création : `interval()`</h3>
      <p class="mt-2">
        L'opérateur statique <strong><code>interval(millis)</code></strong> est un *opérateur de création* de RxJS. Il crée un Observable qui émet des nombres entiers successifs (0, 1, 2, ...) à intervalles réguliers définis en millisecondes. C'est idéal pour simuler un compteur ou une mise à jour en temps réel.
      </p>
    </div>
  </div>

  <div class="card bg-base-100 shadow-xl">
    <div class="card-body">
      <h3 class="card-title text-primary">Exemple pratique avec un compteur :</h3>
      <p>
        Cet exemple utilise l'observable <code>interval()</code> de <code>rxjs</code>. Il émet une nouvelle valeur
        incrémentée toutes les secondes.
      </p>
      <div class="mt-4">
        <h5 class="font-semibold text-success">Valeur actuelle :</h5>
        <p class="text-2xl font-bold">{{ currentValue }}</p>
      </div>
    </div>
  </div>

  <div class="alert alert-success shadow-lg">
    <div>
      <h4 class="font-bold text-lg">Exemples d'utilisation dans des cas réels :</h4>
      <ul class="list-disc list-inside mt-2 space-y-1">
        <li><strong>Appels API :</strong> Récupérer des données dynamiques avec <code>HttpClient</code>.</li>
        <li><strong>Formulaires réactifs :</strong> Détecter et valider les entrées utilisateur.</li>
        <li><strong>Données en temps réel :</strong> Utiliser des WebSockets pour recevoir des mises à jour en direct.</li>
        <li><strong>Écoute d'événements :</strong> Gérer des événements utilisateur comme les clics ou le défilement de page.</li>
        <li><strong>Animation :</strong> Synchroniser des transitions complexes.</li>
      </ul>
    </div>
  </div>
</div>
